<html>
<head>
    <title>Title</title>
    <style type="text/css">
        /* fallback */
        @font-face {
            font-family: 'Material Icons';
            font-style: normal;
            font-weight: 400;
            src: local('Material Icons'), local('MaterialIcons-Regular'),
            url(https://fonts.gstatic.com/s/materialicons/v18/2fcrYFNaTjcS6g4U3t-Y5UEw0lE80llgEseQY3FEmqw.woff2) format('woff2');
        }

        .material-icons {
            font-family: 'Material Icons';
            font-weight: normal;
            font-style: normal;
            font-size: 24px;
            line-height: 1;
            letter-spacing: normal;
            text-transform: none;
            display: inline-block;
            white-space: nowrap;
            word-wrap: normal;
            direction: ltr;
            -webkit-font-feature-settings: 'liga';
            -webkit-font-smoothing: antialiased;
        }
    </style>
    <link href="materialize/css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection"/>
    <link href="materialize/css/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"/>

    <link rel="stylesheet" href="editor.md-master/css/editormd.preview.css" />
    <style>
        .editormd-html-preview {
            width: 90%;
            margin: 0 auto;
        }
    </style>
</head>
<body>
<div class="container">
    <nav>
        <div class="nav-wrapper">
            <a href="#!" class="brand-logo" style="margin-left: 10px;">Stary</a>
            <ul class="right hide-on-med-and-down">
                <li><a href="#">Article</a></li>
                <li><a href="#">Discussion</a></li>
                <!-- Dropdown Trigger -->
                <li><a class="dropdown-button" href="#" data-activates="profile">Dropdown<i class="material-icons right">arrow_drop_down</i></a></li>
                <ul id='profile' class='dropdown-content'>
                    <li><a href="#">Log in</a></li>
                    <li><a href="#">Register</a></li>
                    <li><a href="#">Write Article</a></li>
                    <li class="divider"></li>
                    <li><a href="#">Log out</a></li>
                </ul>
            </ul>
        </div>
    </nav>
    <div style="position: fixed; bottom: 90px; right: 30px;">
        <a class="btn-floating btn-large waves-effect waves-light red"><i class="large material-icons">mode_edit</i></a>
    </div>

    <h2 class="header">Class and structure</h2>
    <h5><i class="material-icons left">perm_identity</i><small>Author:</small> Stary</h5>
    <h5><i class="material-icons left">email</i><small>Email:</small> yzx9610@outlook.com</h5>
    <h5><i class="material-icons left">info_outline</i><small>Description:</small> the brief information about article.</h5>
    <hr>
    <div id="test-editormd-view2">
        <textarea id="append-test" style="display:none;"># Class and structure

Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures. In Swift, you define a class or a structure in a single file, and the external interface to that class or structure is **automatically made available**for other code to use.


## How to name in the class
Whenever you define a new class or structure, you effectively define a brand new Swift type. Give types `UpperCamelCase` names (such as SomeClass and SomeStructure here) to match the capitalisation of standard Swift types (such as String, Int, and Bool). Conversely, always give properties and method `slowerCamelCase` names (such as frameRate and incrementCount) to differentiate them from type names.


## identical and equal
Note that “identical to” (represented by three equals signs, or ===) does not mean the same thing as “equal to” (represented by two equals signs, or ==):

* 		“Identical to” means that two constants or variables of class type refer to exactly the same class instance.
* 		“Equal to” means that two instances are considered “equal” or “equivalent” in value, for some appropriate meaning of “equal”, as defined by the type’s designer. 

```
	.	if tenEighty === alsoTenEighty {
	.	    print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")
	.	}
	.	// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."
```

## class and structure
However, structure instances are always passed by value, and class instances are always passed by reference. This means that they are suited to different kinds of tasks. As you consider the data constructs and functionality that you need for a project, decide whether each data construct should be defined as a class or as a structure.

## properties

### Lazy stored properties
You must always declare a lazy property as a variable (with the var keyword), because its initial value might not be retrieved until after instance initialisation completes. Constant properties must always have a value before initialisation completes, and therefore cannot be declared as lazy.


```
	.	class DataImporter {
	.	    /*
	.	     DataImporter is a class to import data from an external file.
	.	     The class is assumed to take a non-trivial amount of time to initialize.
	.	     */
	.	    var fileName = "data.txt"
	.	    // the DataImporter class would provide data importing functionality here
	.	}
	.
	.	class DataManager {
	.	    lazy var importer = DataImporter()
	.	    var data = [String]()
	.	    // the DataManager class would provide data management functionality here
	.	}
	.
	.	let manager = DataManager()
	.	manager.data.append("Some data")
	.	manager.data.append("Some more data")
	.	// the DataImporter instance for the importer property has not yet been created
```

### computed properties
In addition to stored properties, classes, structures, and enumerations can define computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.


```
struct point {
  var x : Double = 0.0
  var y : Double = 0.0
}
struct Size {
  var height = 0.0
  var width = 0.0
}
/**
 *  It has to be a `struct` type, because struct is a pass-by-value.
 *  But `class` is pass-by-reference, and it has to exist the init function.
 */
struct shape {
  var origin = point()
  var size = Size()
  var center : point {
    /**
     *  It can be used as right value and return a corresponding centre point.
     */
    get {
      let centerX = origin.x + (size.width / 2)
      let centerY = origin.y + (size.height / 2)
      return point(x: centerX, y: centerY)
    }
    /**
     *  It can be used as a left value and change the properties with a new point.
     *  what's more, the paramount can even be ignored for shorthand.
     */
    set(newValue) {
      origin.x = newValue.x
      origin.y = newValue.y
    }
  }
}
```

### Read-only computed properties
A computed property with a getter but no setter is known as a read-only computed property. A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.


```
	.	struct Cuboid {
	.	    var width = 0.0, height = 0.0, depth = 0.0
	.	    var volume: Double {
	.	        return width * height * depth
	.	    }
	.	}
	.	let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
	.	print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
	.	// Prints "the volume of fourByFiveByTwo is 40.0"
```

### properties observer
Property observers observe and respond to changes in a property’s value. Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.

You have the option to define either or both of these observers on a property:

* 		`willSet` is called just before the value is stored. 
* 		`didSet` is called immediately after the new value is stored. 
If you implement a `willSet` observer, it’s passed the new property value as a constant parameter. You can specify a name for this parameter as part of your willSet implementation. If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of `newValue`.

Similarly, if you implement a didSet observer, it’s passed a constant parameter containing the old property value. You can name the parameter or use the default parameter name of `oldValue`. If you assign a value to a property within its own didSet observer, the new value that you assign replaces the one that was just set.


```
	.	class StepCounter {
	.	    var totalSteps: Int = 0 {
	.	        willSet(newTotalSteps) {
	.	            print("About to set totalSteps to \(newTotalSteps)")
	.	        }
	.	        didSet {
	.	            if totalSteps > oldValue  {
	.	                print("Added \(totalSteps - oldValue) steps")
	.	            }
	.	        }
	.	    }
	.	}
	.	let stepCounter = StepCounter()
	.	stepCounter.totalSteps = 200
	.	// About to set totalSteps to 200
	.	// Added 200 steps
	.	stepCounter.totalSteps = 360
	.	// About to set totalSteps to 360
	.	// Added 160 steps
	.	stepCounter.totalSteps = 896
	.	// About to set totalSteps to 896
	.	// Added 536 steps
```

### type properties syntax

In C and Objective-C, you define static constants and variables associated with a type as global static variables. In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.

You define type properties with the static keyword. For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclass’s implementation. The example below shows the syntax for stored and computed type properties:


```
	.	struct SomeStructure {
	.	    static var storedTypeProperty = "Some value."
	.	    static var computedTypeProperty: Int {
	.	        return 1
	.	    }
	.	}
	.	enum SomeEnumeration {
	.	    static var storedTypeProperty = "Some value."
	.	    static var computedTypeProperty: Int {
	.	        return 6
	.	    }
	.	}
	.	class SomeClass {
	.	    static var storedTypeProperty = "Some value."
	.	    static var computedTypeProperty: Int {
	.	        return 27
	.	    }
	.	    class var overrideableComputedTypeProperty: Int {
	.	        return 107
	.	    }
	.	}
```

### Querying and Setting Type Properties
Type properties are queried and set with dot syntax, just like instance properties. However, type properties are queried and set on the type, not on an instance of that type. For example:

```
	.	print(SomeStructure.storedTypeProperty)
	.	// Prints "Some value."
	.	SomeStructure.storedTypeProperty = "Another value."
	.	print(SomeStructure.storedTypeProperty)
	.	// Prints "Another value."
	.	print(SomeEnumeration.computedTypeProperty)
	.	// Prints "6"
	.	print(SomeClass.computedTypeProperty)
	.	// Prints "27"
```

You can control the value in the allowed range by writing the following codes with `didSet`.

```
	.	struct AudioChannel {
	.	    static let thresholdLevel = 10
	.	    static var maxInputLevelForAllChannels = 0
	.	    var currentLevel: Int = 0 {
	.	        didSet {
	.	            if currentLevel > AudioChannel.thresholdLevel {
	.	                // cap the new audio level to the threshold level
	.	                currentLevel = AudioChannel.thresholdLevel
	.	            }
	.	            if currentLevel > AudioChannel.maxInputLevelForAllChannels {
	.	                // store this as the new overall maximum input level
	.	                AudioChannel.maxInputLevelForAllChannels = currentLevel
	.	            }
	.	        }
	.	    }
	.	}
```

## method
In practice, you don’t need to write self in your code very often. If you don’t explicitly write self, Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method. This assumption is demonstrated by the use of count (rather ` thanself.count `) inside the three instance methods for Counter.

Here, self disambiguates between a method parameter called x and an instance property that is also called x:

```
	.	struct Point {
	.	    var x = 0.0, y = 0.0
	.	    func isToTheRightOfX(x: Double) -> Bool {
	.	        return self.x > x
	.	    }
	.	}
	.	let somePoint = Point(x: 4.0, y: 5.0)
	.	if somePoint.isToTheRightOfX(1.0) {
	.	    print("This point is to the right of the line where x == 1.0")
	.	}
	.	// Prints "This point is to the right of the line where x == 1.0"
```
Without the self prefix, Swift would assume that both uses of x referred to the method parameter called x.

## Modifying Value Types from Within Instance Methods
### mutating method
 if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to mutating behaviour for that method. The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends. The method can also assign a completely new instance to its implicit self property, and this new instance will replace the existing one when the method ends.

You can opt in to this behaviour by placing the mutating keyword before the func keyword for that method.
If you don't put mutating as prefix, properties can not be changed in func.

```
	.	struct Point {
	.	    var x = 0.0, y = 0.0
	.	    mutating func moveByX(deltaX: Double, y deltaY: Double) {
	.	        x += deltaX
	.	        y += deltaY
	.	    }
	.	}
	.	var somePoint = Point(x: 1.0, y: 1.0)
	.	somePoint.moveByX(2.0, y: 3.0)
	.	print("The point is now at (\(somePoint.x), \(somePoint.y))")
	.	// Prints "The point is now at (3.0, 4.0)"
```

### type method
Instance methods, as described above, are methods that are called on an instance of a particular type. You can also define methods that are called on the type itself. These kinds of methods are called type methods. You indicate type methods by writing the static keyword before the method’s func keyword. Classes may also use the class keyword to allow subclasses to override the superclass’s implementation of that method.

```
	.	struct LevelTracker {
	.	    static var highestUnlockedLevel = 1
	.	    static func unlockLevel(level: Int) {
	.	        if level > highestUnlockedLevel { highestUnlockedLevel = level }
	.	    }
	.	    static func levelIsUnlocked(level: Int) -> Bool {
	.	        return level <= highestUnlockedLevel
	.	    }
	.	    var currentLevel = 1
	.	    mutating func advanceToLevel(level: Int) -> Bool {
	.	        if LevelTracker.levelIsUnlocked(level) {
	.	            currentLevel = level
	.	            return true
	.	        } else {
	.	            return false
	.	        }
	.	    }
	.	}
```


### inheritance
base class:

```
	.	class Vehicle {
	.	    var currentSpeed = 0.0
	.	    var description: String {
	.	        return "traveling at \(currentSpeed) miles per hour"
	.	    }
	.	    func makeNoise() {
	.	        // do nothing - an arbitrary vehicle doesn't necessarily make a noise
	.	    }
	.	}
```

and subclass like below:


```
	.	class Vehicle {
	.	    var currentSpeed = 0.0
	.	    var description: String {
	.	        return "traveling at \(currentSpeed) miles per hour"
	.	    }
	.	    func makeNoise() {
	.	        // do nothing - an arbitrary vehicle doesn't necessarily make a noise
	.	    }
	.	}
```

#### Override
To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the `override` keyword. Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake. Overriding by accident can cause unexpected behavior, and any overrides without the `override` keyword are diagnosed as an error when your code is compiled.


```
	.	class Train: Vehicle {
	.	    override func makeNoise() {
	.	        print("Choo Choo")
	.	    }
	.	}
```


```
	.	class Car: Vehicle {
	.	    var gear = 1
	.	    override var description: String {
	.	        return super.description + " in gear \(gear)"
	.	    }
	.	}
```


#### access the base class:
Where this is appropriate, you access the superclass version of a method, property, or subscript by using the super prefix:

* 		An overridden method named someMethod() can call the superclass version of someMethod() by calling `super.someMethod()` within the overriding method implementation. 
* 		An overridden property called someProperty can access the superclass version of someProperty as `super.someProperty` within the overriding getter or setter implementation. 
* 		An overridden subscript for someIndex can access the superclass version of the same subscript as `super[someIndex]` from within the overriding subscript implementation. 

#### prevent override
Using `final` as prefix, it can prevent the subclass writers overriding method or properties. What's more, you can even set the whole class as final. Any attempt to subclass a final class is reported as a compile-time error.

## initialisation
Initializers are called to create a new instance of a particular type. In its simplest form, an initializer is like an instance method with no parameters, written using the init keyword:


```
	.	struct Fahrenheit {
	.	    var temperature: Double
	.	    init() {
	.	        temperature = 32.0
	.	    }
	.	}
	.	var f = Fahrenheit()
	.	print("The default temperature is \(f.temperature)° Fahrenheit")
	.	// Prints "The default temperature is 32.0° Fahrenheit"
```


==If a property always takes the same initial value, provide a default value rather than setting a value within an initializer.==


### Initialization Parameters
The first parameter is the external var and the second name is  the local var which can be accessed in the scope in the function.

```
	.	struct Celsius {
	.	    var temperatureInCelsius: Double
	.	    init(fromFahrenheit fahrenheit: Double) {
	.	        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
	.	    }
	.	    init(fromKelvin kelvin: Double) {
	.	        temperatureInCelsius = kelvin - 273.15
	.	    }
	.	}
	.	let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
	.	// boilingPointOfWater.temperatureInCelsius is 100.0
	.	let freezingPointOfWater = Celsius(fromKelvin: 273.15)
	.	// freezingPointOfWater.temperatureInCelsius is 0.0
```

### Local and External Parameter Names

```
	.	struct Color {
	.	    let red, green, blue: Double
	.	    init(red: Double, green: Double, blue: Double) {
	.	        self.red   = red
	.	        self.green = green
	.	        self.blue  = blue
	.	    }
	.	    init(white: Double) {
	.	        red   = white
	.	        green = white
	.	        blue  = white
	.	    }
	.	}
```
Note that it is not possible to call these initializers without using external parameter names. External names must always be used in an initializer if they are defined, and **omitting them is a compile-time error**:

### Initializer Parameters Without External Names

```
.	struct Celsius {
	.	    var temperatureInCelsius: Double
	.	    init(fromFahrenheit fahrenheit: Double) {
	.	        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
	.	    }
	.	    init(fromKelvin kelvin: Double) {
	.	        temperatureInCelsius = kelvin - 273.15
	.	    }
	.	    init(_ celsius: Double) {
	.	        temperatureInCelsius = celsius
	.	    }
	.	}
	.	let bodyTemperature = Celsius(37.0)
	.	// bodyTemperature.temperatureInCelsius is 37.0
```

### Memberwise Initializers for Structure Types
`struct` type has default initializers.

```
	.	struct Size {
	.	    var width = 0.0, height = 0.0
	.	}
	.	let twoByTwo = Size(width: 2.0, height: 2.0)

```

### Initializer Delegation for Value Types
Initializers can call other initializers to perform part of an instance’s initialization. This process, known asinitializer delegation, avoids duplicating code across multiple initializers.

Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it is a structure) for that type.This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers.


### Designated Initializers and Convenience Initializers
`Designated initializers` are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.

`Convenience initializers` are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.

#### syntax
Designated initializers for classes are written in the same way as simple initializers for value types:

		init(parameters) { 
		    statements 
		}
 
Convenience initializers are written in the same style, but with the convenience modifier placed before theinit keyword, separated by a space:


		convenience init(parameters) { 
		    statements 
		}

To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:
Rule 1

* A designated initializer must call a designated initializer from its immediate superclass.

Rule 2

* A convenience initializer must call another initializer from the same class.

Rule 3

* A convenience initializer must ultimately call a designated initializer.
* A simple way to remember this is:
		Designated initializers must always delegate up. 
		Convenience initializers must always delegate across. 
![](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png)


The figure below shows a more complex class hierarchy for four classes. It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:

![](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png)



        </textarea>
    </div>



</div>
<footer class="page-footer">
    <div class="container">
        <div class="row">
            <div class="col l6 s12">
                <h5 class="white-text">About Stary!</h5>
                <p class="grey-text text-lighten-4">If you wanna write article to share with others you can just send me a email.</p>
            </div>
        </div>
    </div>
    <div class="footer-copyright">
        <div class="container">
            © 2016 Copyright Stary. All right reserved!
        </div>
    </div>
</footer>

<script src="editor.md-master/examples/js/jquery.min.js"></script>
<script src="editor.md-master/lib/marked.min.js"></script>
<script src="editor.md-master/lib/prettify.min.js"></script>

<script src="editor.md-master/lib/raphael.min.js"></script>
<script src="editor.md-master/lib/underscore.min.js"></script>
<script src="editor.md-master/lib/sequence-diagram.min.js"></script>
<script src="editor.md-master/lib/flowchart.min.js"></script>
<script src="editor.md-master/lib/jquery.flowchart.min.js"></script>

<script src="editor.md-master/editormd.js"></script>
<script type="text/javascript">
    $(function() {
        var testEditormdView, testEditormdView2;

        $.get("test.md", function(markdown) {

            testEditormdView = editormd.markdownToHTML("test-editormd-view", {
                markdown        : markdown ,//+ "\r\n" + $("#append-test").text(),
                //htmlDecode      : true,       // ?? HTML ????????????????
                htmlDecode      : "style,script,iframe",  // you can filter tags decode
                //toc             : false,
                tocm            : true,    // Using [TOCM]
                //tocContainer    : "#custom-toc-container", // ??? ToC ???
                //gfm             : false,
                //tocDropdown     : true,
                // markdownSourceCode : true, // ???? Markdown ????????????? Textarea ??
                emoji           : true,
                taskList        : true,
                tex             : true,  // ?????
                flowChart       : true,  // ?????
                sequenceDiagram : true,  // ?????
            });

            //console.log("???? jQuery ?? =>", testEditormdView);

            // ??Markdown??
            //console.log(testEditormdView.getMarkdown());

            //alert(testEditormdView.getMarkdown());
        });

        testEditormdView2 = editormd.markdownToHTML("test-editormd-view2", {
            htmlDecode      : "style,script,iframe",  // you can filter tags decode
            emoji           : true,
            taskList        : true,
            tex             : true,  // ?????
            flowChart       : true,  // ?????
            sequenceDiagram : true,  // ?????
        });
    });
</script>

<!--  Scripts-->
<script src="materialize/jquery-3.1.0.min.js.js"></script>
<script src="materialize/js/materialize.js"></script>
<script src="materialize/js/materialize.min.js"></script>
</body>
</html>
